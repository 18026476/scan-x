import 'dart:convert';
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'dart:convert';
import 'settings_service.dart';

/// Basic risk level used across the app.
enum RiskLevel {
  low,
  medium,
  high,
}

/// Represents a single open port on a host.
class OpenPort {
  final int port;
  final String protocol;
  final String serviceName;

  OpenPort({
    required this.port,
    required this.protocol,
    required this.serviceName,
  });

  /// Backwards-compat: some UI still calls `port.service`.
  String get service => serviceName;
}

/// Represents a detected host in the scan result.
class DetectedHost {
  final String address; // IP or hostname
  final String? hostname;
  final List<OpenPort> openPorts;
  final RiskLevel risk;

  DetectedHost({
    required this.address,
    required this.hostname,
    required this.openPorts,
    required this.risk,
  });

  /// Backwards-compat: older code uses `host.ip`.
  String get ip => address;
}

/// Overall scan result from a single Smart/Full scan.
class ScanResult {
  final String target;
  final DateTime startedAt;
  final DateTime finishedAt;
  final List<DetectedHost> hosts;

  ScanResult({
    required this.target,
    required this.startedAt,
    required this.finishedAt,
    required this.hosts,
  });
}

/// Main service that talks to nmap and parses output.
class ScanService {
  ScanService._internal();
  static final ScanService _instance = ScanService._internal();
  factory ScanService() => _instance;

  /// Last completed scan (Smart or Full).
  ScanResult? lastResult;

  // ---------------------------------------------------------------------------
  // PUBLIC API
  // ---------------------------------------------------------------------------

  /// Fast "Smart Scan" Ã¢â‚¬â€œ focuses on common ports and speed.
  Future<ScanResult> runSmartScan(String target) async {
    final settings = SettingsService().settings;
    final started = DateTime.now();

    final args = _buildSmartScanArgs(target, settings);
    final stdoutStr = await _runNmap(args);

    final hosts = _parseNmapOutput(stdoutStr);
    final finished = DateTime.now();

    final result = ScanResult(
      target: target,
      startedAt: started,
      finishedAt: finished,
      hosts: hosts,
    );

    lastResult = result;
    return result;
  }

  /// Deep "Full Scan" Ã¢â‚¬â€œ scans all 1Ã¢â‚¬â€œ65535 ports.
  Future<ScanResult> runFullScan(String target) async {
    final settings = SettingsService().settings;
    final started = DateTime.now();

    final args = _buildFullScanArgs(target, settings);
    final stdoutStr = await _runNmap(args);

    final hosts = _parseNmapOutput(stdoutStr);
    final finished = DateTime.now();

    final result = ScanResult(
      target: target,
      startedAt: started,
      finishedAt: finished,
      hosts: hosts,
    );

    lastResult = result;
    return result;
  }

  /// Helper: some UI calls `ScanService().getRiskLevel(host)`.
  RiskLevel getRiskLevel(DetectedHost host) {
    return _calculateRiskLevel(host.openPorts);
  }

  // ---------------------------------------------------------------------------
  // ARG BUILDERS
  // ---------------------------------------------------------------------------

  List<String> _buildSmartScanArgs(String target, ScanSettings settings) {
    // Base options: service detection + faster timing.
    final args = <String>[
      '-sV',
      '-T4',
    ];

    // ScanMode influences which ports & timing we use.
    switch (settings.scanMode) {
      case ScanMode.performance:
        // Very fast Ã¢â‚¬â€œ top 200 ports.
        args.addAll(['--top-ports', '200']);
        break;
      case ScanMode.balanced:
        // Default Ã¢â‚¬â€œ top 1000 ports.
        args.addAll(['--top-ports', '1000']);
        break;
      case ScanMode.paranoid:
        // More thorough even for "Smart" Ã¢â‚¬â€œ top 5000 ports.
        args.addAll(['--top-ports', '5000', '-T3']);
        break;
    }

    args.add(target);
    return args;
  }

  List<String> _buildFullScanArgs(String target, ScanSettings settings) {
    final args = <String>[
      '-sV',
      '-p',
      '1-65535', // full port space
    ];

    // Tune timing/profile by ScanMode.
    switch (settings.scanMode) {
      case ScanMode.performance:
        // Slightly more aggressive but still full.
        args.add('-T4');
        break;
      case ScanMode.balanced:
        args.add('-T3');
        break;
      case ScanMode.paranoid:
        // Slower, more careful.
        args.add('-T2');
        break;
    }

    args.add(target);
    return args;
  }

  // ---------------------------------------------------------------------------
  // LOW-LEVEL NMAP INVOCATION
  // ---------------------------------------------------------------------------

  Future<String> _runNmap(List<String> args) async {
    final result = await Process.run('nmap', args,
        runInShell: true,
        stdoutEncoding: systemEncoding,
        stderrEncoding: systemEncoding);

    if (result.exitCode != 0) {
      final stderrStr = (result.stderr ?? '').toString();
      throw Exception('nmap failed (exit ${result.exitCode}): $stderrStr');
    }

    return (result.stdout ?? '').toString();
  }

  // ---------------------------------------------------------------------------
  // PARSING
  // ---------------------------------------------------------------------------

  final RegExp _hostRegex = RegExp(r'^Nmap scan report for (.+)$');
  final RegExp _portLineRegex =
      RegExp(r'^(\d+)/(tcp|udp)\s+open\s+([\w\-\?\.\+]+)');

  List<DetectedHost> _parseNmapOutput(String stdoutStr) {
    final lines = stdoutStr.split('\n');

    final hosts = <DetectedHost>[];
    String? currentAddress;
    String? currentHostname;
    final currentPorts = <OpenPort>[];

    void flushCurrentHost() {
      if (currentAddress == null) return;
      final portsCopy = List<OpenPort>.from(currentPorts);
      currentPorts.clear();

      final risk = _calculateRiskLevel(portsCopy);

      hosts.add(
        DetectedHost(
          address: currentAddress!,
          hostname: currentHostname,
          openPorts: portsCopy,
          risk: risk,
        ),
      );

      currentAddress = null;
      currentHostname = null;
    }

    for (var rawLine in lines) {
      final line = rawLine.trimRight();

      // Start of a new host.
      final hostMatch = _hostRegex.firstMatch(line);
      if (hostMatch != null) {
        // If we already had a host, flush it first.
        flushCurrentHost();

        final hostString = hostMatch.group(1) ?? '';

        // hostString examples:
        //  - 192.168.1.10
        //  - mypc (192.168.1.20)
        String address = hostString;
        String? hostname;

        final ipInParens = RegExp(r'(.+)\s+\(([^)]+)\)');
        final ipMatch = ipInParens.firstMatch(hostString);
        if (ipMatch != null) {
          hostname = ipMatch.group(1)?.trim();
          address = ipMatch.group(2)?.trim() ?? address;
        }

        currentAddress = address;
        currentHostname = hostname;
        continue;
      }

      // Port lines.
      final portMatch = _portLineRegex.firstMatch(line);
      if (portMatch != null && currentAddress != null) {
        final port = int.tryParse(portMatch.group(1) ?? '') ?? 0;
        final protocol = portMatch.group(2) ?? 'tcp';
        final service = portMatch.group(3) ?? '?';

        currentPorts.add(
          OpenPort(
            port: port,
            protocol: protocol,
            serviceName: service,
          ),
        );
        continue;
      }
    }

    // Flush last host if pending.
    flushCurrentHost();

    return hosts;
  }

  // ---------------------------------------------------------------------------
  // RISK LEVEL HEURISTICS
  // ---------------------------------------------------------------------------

  RiskLevel _calculateRiskLevel(List<OpenPort> ports) {
    if (ports.isEmpty) {
      return RiskLevel.low;
    }

    bool hasHigh = false;
    bool hasMedium = false;

    for (final p in ports) {
      final s = p.serviceName.toLowerCase();

      // High-risk services: remote admin & file shares exposed.
      if (p.port == 21 ||
          p.port == 23 ||
          p.port == 3389 ||
          p.port == 445 ||
          p.port == 1900 ||
          s.contains('telnet') ||
          s.contains('rdp') ||
          s.contains('smb')) {
        hasHigh = true;
        break;
      }

      // Medium-risk: typical entry points.
      if (p.port == 22 ||
          p.port == 80 ||
          p.port == 443 ||
          p.port == 8080 ||
          s.contains('http') ||
          s.contains('ssh')) {
        hasMedium = true;
      }
    }

    if (hasHigh) return RiskLevel.high;
    if (hasMedium) return RiskLevel.medium;
    return RiskLevel.low;
  }
}
