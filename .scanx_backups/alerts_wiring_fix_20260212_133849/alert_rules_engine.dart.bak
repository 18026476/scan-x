import 'package:scanx_app/core/services/scan_service.dart';
import 'package:scanx_app/core/services/settings_service.dart';

enum AlertSeverity { info, low, medium, high, critical }

enum AlertType {
  newDevice,
  macChanged,
  possibleArpSpoof,
  portExposureSpike,
  highRiskFindings,
  scanCompleted,
}

class AlertEvent {
  final AlertType type;
  final AlertSeverity severity;
  final String title;
  final String message;
  final String? deviceIp;
  final String? evidence;

  const AlertEvent({
    required this.type,
    required this.severity,
    required this.title,
    required this.message,
    this.deviceIp,
    this.evidence,
  });
}

class AlertRulesEngine {
  List<AlertEvent> buildEvents({
    required ScanResult current,
    required Map<String, dynamic>? previousSnapshot,
    required Map<String, String> currentIpToMac,
  }) {
    final s = SettingsService();

    final prevDevices = (previousSnapshot?['devices'] as Map?)?.cast<String, dynamic>() ?? <String, dynamic>{};
    final prevIpSet = prevDevices.keys.toSet();
    final currentIps = current.hosts.map((h) => h.address).toSet();

    final events = <AlertEvent>[];

    final sens = s.alertSensitivity.round().clamp(0, 2);
    final portSpikeThreshold = sens == 0 ? 10 : (sens == 1 ? 6 : 4);
    final highRiskNotifyMin = sens == 0 ? 2 : 1;

    if (s.alertNewDevice) {
      final newIps = currentIps.difference(prevIpSet);
      for (final ip in newIps) {
        // Gate "new device" notifications
        if (s.notifyNewDevice) {
          events.add(AlertEvent(
            type: AlertType.newDevice,
            severity: AlertSeverity.medium,
            title: 'New device detected',
            message: 'A new device appeared on your network.',
            deviceIp: ip,
            evidence: 'IP $ip was not present in the previous snapshot.',
          ));
        }

        // Gate "unknown device" notifications (conservative heuristic)
        if (s.notifyUnknownDevice) {
          final host = current.hosts.cast<dynamic?>().firstWhere(
                (h) => (h != null) && (h.address == ip),
                orElse: () => null,
              );
          final hn = (host == null) ? '' : (host.hostname ?? '');
          final ven = (host == null) ? '' : (host.vendor ?? '');
          final isUnknown =
              hn.trim().isEmpty || ven.trim().isEmpty || ven.toLowerCase() == 'unknown';

          if (isUnknown) {
            events.add(AlertEvent(
              type: AlertType.unknownDevice,
              severity: AlertSeverity.medium,
              title: 'Unknown device detected',
              message: 'A new device appeared but could not be identified.',
              deviceIp: ip,
              evidence:
                  'New IP $ip with missing/unknown vendor or hostname (hostname="$hn", vendor="$ven").',
            ));
          }
        }
      }
    }

        if (s.alertMacChange) {
      for (final ip in currentIps.intersection(prevIpSet)) {
        final prevMac = ((prevDevices[ip] as Map?)?['mac'] ?? '').toString().toLowerCase();
        final nowMac = (currentIpToMac[ip] ?? '').toLowerCase();
        if (prevMac.isNotEmpty && nowMac.isNotEmpty && prevMac != nowMac) {
          events.add(AlertEvent(
            type: AlertType.macChanged,
            severity: AlertSeverity.high,
            title: 'Device MAC changed',
            message: 'A device on the same IP address has a different MAC than before.',
            deviceIp: ip,
            evidence: 'Previous MAC $prevMac †’ Current MAC $nowMac',
          ));
        }
      }
    }

    if (s.alertArpSpoof) {
      final macToIps = <String, List<String>>{};
      currentIpToMac.forEach((ip, mac) {
        final m = mac.toLowerCase();
        if (m.isEmpty) return;
        macToIps.putIfAbsent(m, () => <String>[]).add(ip);
      });

      final suspicious = macToIps.entries.where((e) => e.value.length >= 2);
      for (final e in suspicious) {
        events.add(AlertEvent(
          type: AlertType.possibleArpSpoof,
          severity: AlertSeverity.high,
          title: 'Possible ARP spoofing',
          message: 'The same MAC address appears on multiple IPs.',
          evidence: 'MAC ${e.key} seen on IPs: ${e.value.join(", ")}',
        ));
      }
    }

    if (s.alertPortScanAttempts && previousSnapshot != null) {
      for (final h in current.hosts) {
        final prev = (prevDevices[h.address] as Map?)?.cast<String, dynamic>();
        final prevOpen = (prev?['openPorts'] is int)
            ? prev!['openPorts'] as int
            : int.tryParse('${prev?['openPorts'] ?? 0}') ?? 0;

        final nowOpen = h.openPorts.length;
        final delta = nowOpen - prevOpen;
        if (delta >= portSpikeThreshold) {
          events.add(AlertEvent(
            type: AlertType.portExposureSpike,
            severity: AlertSeverity.medium,
            title: 'Port exposure spike detected',
            message: 'A device suddenly shows many more open ports than the last scan.',
            deviceIp: h.address,
            evidence: 'Open ports increased from $prevOpen †’ $nowOpen (Î” $delta)',
          ));
        }
      }
    }

    final highRiskCount = current.hosts.where((h) => h.risk == RiskLevel.high).length;
    if (s.notifyHighRisk && highRiskCount >= highRiskNotifyMin) {
      events.add(AlertEvent(
        type: AlertType.highRiskFindings,
        severity: AlertSeverity.high,
        title: 'High-risk devices found',
        message: 'Your scan detected $highRiskCount high-risk device(s).',
        evidence: 'Risk is based on scan scoring + open ports/services (where available).',
      ));
    }


    // Router / IoT advisory notifications (keyword-based, conservative)
    if (s.notifyRouterVuln || s.notifyIotWarning) {
      final joined = (current.summary.highRiskIssues).join(' ').toLowerCase();

      final routerHit = joined.contains('router') ||
          joined.contains('upnp') ||
          joined.contains('wps') ||
          joined.contains('dns') ||
          joined.contains('firmware');

      final iotHit = joined.contains('iot') ||
          joined.contains('camera') ||
          joined.contains('dvr') ||
          joined.contains('doorbell') ||
          joined.contains('smart') ||
          joined.contains('tv');

      if (s.notifyRouterVuln && routerHit) {
        events.add(AlertEvent(
          type: AlertType.routerVuln,
          severity: AlertSeverity.high,
          title: 'Router security warning',
          message: 'High-risk router-related findings were detected.',
          evidence: 'Matched keywords in high-risk issues.',
        ));
      }

      if (s.notifyIotWarning && iotHit) {
        events.add(AlertEvent(
          type: AlertType.iotWarning,
          severity: AlertSeverity.high,
          title: 'IoT security warning',
          message: 'High-risk IoT-related findings were detected.',
          evidence: 'Matched keywords in high-risk issues.',
        ));
      }
    }
    if (s.notifyScanCompleted) {
      events.add(AlertEvent(
        type: AlertType.scanCompleted,
        severity: AlertSeverity.info,
        title: 'Scan completed',
        message: 'Scan completed for ${current.target}',
        evidence: 'Hosts: ${current.hosts.length}',
      ));
    }

    return events;
  }
}
