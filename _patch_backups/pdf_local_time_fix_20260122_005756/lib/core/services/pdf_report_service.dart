import 'dart:typed_data';

import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

import 'package:scanx_app/core/utils/text_sanitizer.dart';
import 'package:scanx_app/core/utils/text_sanitize.dart';

class PdfReportService {
  
  /* SCANX_V16C_PDF_ASCII_BEGIN */
  // V16C: Force ASCII-safe output to avoid Helvetica unicode warnings and "garbage" glyphs.
    // V16C: Force ASCII-safe output to avoid Helvetica unicode warnings and "garbage" glyphs.
  String _safe(dynamic v) {
    var s = scanxTextSafe((v ?? '').toString());

    // Common offenders from Windows PDF logs:
    // - (U+2014), - (U+2013), â‚¬ (U+20AC), â„¢ (U+2122), and replacement char ï¿½ (U+FFFD)
    s = s
        .replaceAll('\u2014', '-')     // em dash
        .replaceAll('\u2013', '-')     // en dash
        .replaceAll('\u20AC', 'EUR')   // euro sign
        .replaceAll('\u2122', 'TM')    // trademark
        .replaceAll('\uFFFD', '');     // replacement char

    // Normalize NBSP
    s = s.replaceAll('\u00A0', ' ');

    return s;
  }
  /* SCANX_V16C_PDF_ASCII_END */

  DateTime? _scanxTryParseIso(String s) {
    try {
      return DateTime.tryParse(s);
    } catch (_) {
      return null;
    }
  }

  Future<Uint8List> buildReport({required Map<String, dynamic> reportJson}) async {

    final doc = pw.Document();

    final meta = (reportJson['scanMeta'] as Map?)?.cast<String, dynamic>() ?? <String, dynamic>{};
    final scanTimeUtc = _safe(meta['scanTimeUtc'] ?? DateTime.now().toUtc().toIso8601String());
    final scanTimeLocal = _safe(meta['scanTimeLocal'] ?? DateTime.now().toLocal().toIso8601String());
    final startedAtLocal = _safe(meta['startedAtLocal'] ?? '-');
    final finishedAtLocal = _safe(meta['finishedAtLocal'] ?? '-');
    final durationSec = _safe(meta['durationSec'] ?? '-');
final targetCidr  = _safe(meta['targetCidr'] ?? '-');
    final scanMode    = _safe(meta['scanMode'] ?? '-');

    final riskScore = (reportJson['riskScore'] as Map?)?.cast<String, dynamic>() ?? <String, dynamic>{};
    final riskLabel = _safe(riskScore['label'] ?? riskScore['rating'] ?? 'Low');
    final riskValue = _safe(riskScore['risk'] ?? riskScore['score'] ?? 0);
    final healthVal = _safe(riskScore['health'] ?? 100);

    final findings = (reportJson['findings'] as List?)?.cast<dynamic>() ?? const <dynamic>[];
    final devices  = (reportJson['devicesInScan'] as List?)?.cast<dynamic>() ?? const <dynamic>[];
    final topPorts = (reportJson['topOpenPorts'] as List?)?.cast<dynamic>() ?? const <dynamic>[];

    final severityDist = (reportJson['severityDistribution'] as Map?)?.cast<String, dynamic>() ?? <String, dynamic>{};
    final settingsSnap = (reportJson['settingsSnapshot'] as Map?)?.cast<String, dynamic>() ?? <String, dynamic>{};
    final mlInsights   = (reportJson['mlInsights'] as List?)?.cast<dynamic>().map((x) => x.toString()).toList() ?? const <String>[];

    doc.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(28),
        build: (context) => [
          pw.Text('SCAN-X Security Report', style: pw.TextStyle(fontSize: 22, fontWeight: pw.FontWeight.bold)),
          pw.SizedBox(height: 6),
          pw.Text('Generated by SCAN-X Cyber Labs', style: const pw.TextStyle(fontSize: 10)),
          pw.Divider(),

          pw.Text('Scan Time (UTC): $scanTimeUtc'),
          pw.Text('Target CIDR: $targetCidr'),
          pw.Text('Scan Mode: $scanMode'),
          pw.SizedBox(height: 10),

          _box(
            pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Text('Overall Risk', style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 4),
                pw.Text('Risk Score: $riskValue ($riskLabel)'),
                pw.Text('Network Health: $healthVal / 100', style: const pw.TextStyle(fontSize: 9)),
              ],
            ),
          ),

          // Devices discovered (Smart Scan)
          _sectionTitle('Devices in Scan'),
          _devicesTable(devices),

          // Device recommendations
          _sectionTitle('Device Recommendations'),
          _deviceRecommendations(devices),

          // Findings
          _sectionTitle('Findings'),
          pw.SizedBox(height: 6),
          if (findings.isEmpty)
            pw.Text('No findings were detected.')
          else
            pw.Column(children: findings.map((f) => _findingCard(f)).toList()),

          // Top open ports
          _sectionTitle('Top Open Ports'),
          _topPortsTable(topPorts),

          // Severity distribution (ASCII-safe)
          _sectionTitle('Severity Distribution'),
          _severityBarChart(severityDist),

          // Settings snapshot
          _sectionTitle('Settings Snapshot'),
          _settingsSnapshot(settingsSnap),

          // ML Insights (plain English)
          _sectionTitle('ML Insights (beta)'),
          _mlInsights(mlInsights),

          pw.SizedBox(height: 12),
          pw.Text('Disclaimer', style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold)),
          pw.SizedBox(height: 4),
          pw.Text(
            'This report is informational and does not perform exploitation or intrusive actions. '
            'Always obtain authorization before scanning any networks you do not own.',
            style: const pw.TextStyle(fontSize: 9),
          ),
        ],
      ),
    );

    return doc.save();
  }

  // -------------------------
  // PDF helpers (ASCII-safe)
  // -------------------------

  pw.Widget _sectionTitle(String t) => pw.Padding(
    padding: const pw.EdgeInsets.only(top: 12, bottom: 6),
    child: pw.Text(t, style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold)),
  );

  pw.Widget _box(pw.Widget child) => pw.Container(
    padding: const pw.EdgeInsets.all(10),
    decoration: pw.BoxDecoration(
      border: pw.Border.all(width: 0.8, color: PdfColors.grey700),
      borderRadius: pw.BorderRadius.circular(6),
    ),
    child: child,
  );

  pw.Widget _findingCard(dynamic fDyn) {
    final m = (fDyn is Map) ? fDyn.cast<String, dynamic>() : <String, dynamic>{};

    final title = _safe(m['title'] ?? 'Finding');
    final severity = _safe(m['severity'] ?? '-');
    final status = _safe(m['status'] ?? '-');
    final deviceIp = _safe(m['deviceIp'] ?? '-');
    final evidence = _safe(m['evidence'] ?? '');
    final rec = _safe(m['recommendation'] ?? '');

    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 10),
      padding: const pw.EdgeInsets.all(10),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(width: 0.6, color: PdfColors.grey600),
        borderRadius: pw.BorderRadius.circular(6),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(title, style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
          pw.SizedBox(height: 2),
          pw.Text('Severity: $severity'),
          pw.Text('Status: $status'),
          pw.Text('Device: $deviceIp'),
          if (evidence.trim().isNotEmpty) pw.Text('Evidence: $evidence'),
          if (rec.trim().isNotEmpty) pw.Text('What to do: $rec'),
        ],
      ),
    );
  }

  pw.Widget _devicesTable(List<dynamic> devices) {
    if (devices.isEmpty) {
      return pw.Text('No devices were captured in reportJson. (Upstream JSON is incomplete)');
    }

    final rows = <pw.TableRow>[
      pw.TableRow(children: [
        _th('IP'),
        _th('Name'),
        _th('Open Ports'),
        _th('Risk'),
      ]),
    ];

    for (final d in devices) {
      if (d is! Map) continue;
      final m = d.cast<String, dynamic>();

      final ip = _safe(m['ip'] ?? '-');
      final name = _safe(m['name'] ?? '-');
      final risk = _safe(m['risk'] ?? '-');

      final ports = (m['openPorts'] is List)
          ? (m['openPorts'] as List).map((x) => x.toString()).toList()
          : const <String>[];
      final portsText = ports.isEmpty ? '-' : ports.join(', ');

      rows.add(pw.TableRow(children: [
        _td(ip),
        _td(name),
        _td(portsText),
        _td(risk),
      ]));
    }

    return pw.Table(border: pw.TableBorder.all(width: 0.8), children: rows);
  }

  pw.Widget _deviceRecommendations(List<dynamic> devices) {
    if (devices.isEmpty) return pw.SizedBox();

    final blocks = <pw.Widget>[];

    for (final d in devices) {
      if (d is! Map) continue;
      final m = d.cast<String, dynamic>();

      final ip = _safe(m['ip'] ?? '-');
      final name = _safe(m['name'] ?? '-');
      final risk = _safe(m['risk'] ?? '-');

      final recs = (m['recommendations'] is List)
          ? (m['recommendations'] as List).map((x) => _safe(x)).where((x) => x.trim().isNotEmpty).toList()
          : const <String>[];

      blocks.add(
        pw.Container(
          margin: const pw.EdgeInsets.only(bottom: 8),
          padding: const pw.EdgeInsets.all(8),
          decoration: pw.BoxDecoration(
            border: pw.Border.all(width: 0.6, color: PdfColors.grey600),
            borderRadius: pw.BorderRadius.circular(6),
          ),
          child: pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Text('$name ($ip) - Risk: $risk', style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 10)),
              pw.SizedBox(height: 4),
              if (recs.isEmpty)
                pw.Text('No specific recommendations for this device.', style: const pw.TextStyle(fontSize: 9))
              else
                pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.start,
                  children: recs.map((r) => _dashBullet(r)).toList(),
                ),
            ],
          ),
        ),
      );
    }

    return pw.Column(crossAxisAlignment: pw.CrossAxisAlignment.start, children: blocks);
  }

  pw.Widget _topPortsTable(List<dynamic> topPorts) {
    if (topPorts.isEmpty) return pw.Text('No open ports were captured.');

    final rows = <pw.TableRow>[
      pw.TableRow(children: [
        _th('Port'),
        _th('Seen on devices'),
      ]),
    ];

    for (final e in topPorts) {
      if (e is! Map) continue;
      final m = e.cast<String, dynamic>();
      rows.add(pw.TableRow(children: [
        _td(_safe(m['port'] ?? '-')),
        _td(_safe(m['count'] ?? '-')),
      ]));
    }

    return pw.Table(border: pw.TableBorder.all(width: 0.8), children: rows);
  }

  pw.Widget _asciiBarChart(Map<String, dynamic> seriesDyn) {
    if (seriesDyn.isEmpty) return pw.Text('No severity data.');

    var maxVal = 0;
    seriesDyn.forEach((k, v) {
      final n = (v is int) ? v : int.tryParse(v.toString()) ?? 0;
      if (n > maxVal) maxVal = n;
    });

    final rows = <pw.Widget>[];
    seriesDyn.forEach((k, v) {
      final n = (v is int) ? v : int.tryParse(v.toString()) ?? 0;
      final bars = (maxVal == 0) ? 0 : ((n / maxVal) * 20).round();
      final barStr = List.filled(bars, '#').join(); // ASCII-safe

      rows.add(
        pw.Row(
          children: [
            pw.SizedBox(width: 90, child: pw.Text(_safe(k), style: const pw.TextStyle(fontSize: 9))),
            pw.Expanded(child: pw.Text(barStr, style: const pw.TextStyle(fontSize: 9))),
            pw.SizedBox(width: 25, child: pw.Text(n.toString(), style: const pw.TextStyle(fontSize: 9))),
          ],
        ),
      );
      rows.add(pw.SizedBox(height: 2));
    });

    return _box(pw.Column(crossAxisAlignment: pw.CrossAxisAlignment.start, children: rows));
  }

  pw.Widget _settingsSnapshot(Map<String, dynamic> snap) {
    if (snap.isEmpty) return pw.Text('No settings snapshot present.');

    final rows = <pw.Widget>[];
    snap.forEach((k, v) {
      final on = (v == true);
      rows.add(
        pw.Row(
          mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
          children: [
            pw.Expanded(child: pw.Text(_safe(k), style: const pw.TextStyle(fontSize: 9))),
            pw.Text(on ? 'ON' : 'OFF', style: const pw.TextStyle(fontSize: 9)),
          ],
        ),
      );
      rows.add(pw.SizedBox(height: 2));
    });

    return _box(pw.Column(crossAxisAlignment: pw.CrossAxisAlignment.start, children: rows));
  }

  pw.Widget _mlInsights(List<String> lines) {
    if (lines.isEmpty) return pw.Text('No ML insights available.');

    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: lines.map((t) => _dashBullet(_safe(t))).toList(),
    );
  }

  pw.Widget _dashBullet(String text) => pw.Padding(
    padding: const pw.EdgeInsets.only(bottom: 2),
    child: pw.Text('- $text', style: const pw.TextStyle(fontSize: 9)),
  );

  pw.Widget _th(String t) => pw.Padding(
    padding: const pw.EdgeInsets.all(4),
    child: pw.Text(t, style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 9)),
  );

  pw.Widget _td(String t) => pw.Padding(
    padding: const pw.EdgeInsets.all(4),
    child: pw.Text(t, style: const pw.TextStyle(fontSize: 9)),
  );
  /* SCANX_V16C_SEVERITY_BARCHART */
  // V16C: Proper severity bar chart (grayscale, printer-friendly).
  pw.Widget _severityBarChart(Map<String, dynamic> seriesDyn) {
    if (seriesDyn.isEmpty) return pw.Text('No severity data.');

    int maxVal = 0;
    final normalized = <String, int>{};

    seriesDyn.forEach((k, v) {
      final key = _safe(k);
      final n = (v is int) ? v : int.tryParse(v.toString()) ?? 0;
      normalized[key] = n;
      if (n > maxVal) maxVal = n;
    });

    // Sort: High/Critical first, then Medium, then Low, then others
    final order = <String, int>{
      'High/Critical': 0,
      'High': 0,
      'Critical': 0,
      'Medium': 1,
      'Low': 2,
    };

    final entries = normalized.entries.toList()
      ..sort((a, b) {
        final oa = order[a.key] ?? 9;
        final ob = order[b.key] ?? 9;
        if (oa != ob) return oa.compareTo(ob);
        return b.value.compareTo(a.value);
      });

    final rows = <pw.Widget>[];

    for (final e in entries) {
      final label = e.key;
      final n = e.value;
      final frac = (maxVal == 0) ? 0.0 : (n / maxVal);

      rows.add(
        pw.Row(
          crossAxisAlignment: pw.CrossAxisAlignment.center,
          children: [
            pw.SizedBox(width: 90, child: pw.Text(_safe(label), style: const pw.TextStyle(fontSize: 9))),
            pw.Container(
              width: 220,
              height: 10,
              decoration: pw.BoxDecoration(
                color: PdfColors.grey300,
                borderRadius: pw.BorderRadius.circular(2),
              ),
              child: pw.Align(
                alignment: pw.Alignment.centerLeft,
                child: pw.Container(
                  width: 220 * frac,
                  height: 10,
                  decoration: pw.BoxDecoration(
                    color: PdfColors.grey800,
                    borderRadius: pw.BorderRadius.circular(2),
                  ),
                ),
              ),
            ),
            pw.SizedBox(width: 10),
            pw.SizedBox(width: 30, child: pw.Text(n.toString(), style: const pw.TextStyle(fontSize: 9))),
          ],
        ),
      );

      rows.add(pw.SizedBox(height: 4));
    }

    rows.add(pw.SizedBox(height: 4));
    rows.add(pw.Text('Legend: longer bars = more findings', style: const pw.TextStyle(fontSize: 8)));

    return _box(pw.Column(crossAxisAlignment: pw.CrossAxisAlignment.start, children: rows));
  }
}






